# Алгоритмы поиска
____
## Линейный поиск ([реализация](https://github.com/Skuybedin/csharp-algorithms/blob/main/Search/Linear.cs))
### Применимость
Алгоритм линейного поиска часто используется на практике. Его применение оправдано на **небольших и/или неотсортированных** последовательностях, либо в случае одиночного поиска в неупорядоченном списке.

Когда последовательность состоит из большого числа элементов, и с ней предстоит работать не раз, тогда наиболее оптимальным решением оказывается предварительная сортировка этой последовательности с последующим применением двоичного (рассмотрим позже) или другого, отличного от линейного, алгоритма поиска.

### Преимущества и недостатки
| Преимущества | Недостатки |
|:----------------|----------------:|
| Прост в реализации | В худшем случае осуществляется просмотр всего множества |
| Не требует сортировки значений множества | Используется, если множество содержит небольшое количество элементов |
| Не требует дополнительной памяти |  |
| Может работать в потоковом режиме при непосредственном получении данных из любого источника |  |

### Время работы
| Временная сложность | Время работы | Комментарий |
|----------------|---------|----------------|
| Лучшее | O(1) | В лучшем случае, когда искомый элемент занимает первую позицию, алгоритм произведет всего одно сравнение |
| Среднее | O(n/2) | В среднем этот алгоритм требует n/2n/2 итераций цикла |
| Худшее | O(n) | Худшему случаю соответствуют две ситуации: искомый элемент занимает **последнюю позицию**, или он вовсе **отсутствует** в массиве |

____

## Бинарный поиск ([реализация](https://github.com/Skuybedin/csharp-algorithms/blob/main/Search/Binary.cs))
### Применимость
Применяется на **упорядоченном** массиве c большИм количеством элементов **при ограниченном времени** выполнения. 

### Преимущества и недостатки
| Преимущества | Недостатки |
|:----------------|----------------:|
| Быстрота выполнения поиска | Сложен в реализации |
| Используется, если множество содержит большое количество элементов | Применяться только на упорядоченном множестве |
| Не требует дополнительной памяти | Не может работать в потоковом режиме при непосредственном получении данных из любого источника |

### Время работы
| Временная сложность | Время работы | Комментарий |
|----------------|---------|----------------|
| Лучшее | O(1) | В лучшем случае, когда искомый элемент находится в середине массива, алгоритм произведет всего одно сравнение |
| Среднее | O(logn) | в среднем этот алгоритм требует logn итераций цикла |
| Худшее | O(logn) | Худшему случаю соответствуют две ситуации: искомый элемент находится в последней итерации цикла, или он вовсе **отсутствует** в массиве |

____

## Поиск прыжками ([реализация](https://github.com/Skuybedin/csharp-algorithms/blob/main/Search/Jump.cs))
### Применимость
Применяется на упорядоченном массиве элементов при ограниченном времени выполнения. Если количество элементов не превышает 10^9 и нам важно время выполнения, можно воспользоваться данным поиском. 
Этот поиск также используется вместо бинарного поиска, когда прыжки в обратную сторону затратны. 

### Преимущества и недостатки
| Преимущества | Недостатки |
|:----------------|----------------:|
| Относительно прост в реализации | Применяться только на упорядоченном множестве |
| Используется, если множество содержит большое количество элементов | Не может работать в потоковом режиме при непосредственном получении данных из любого источника |
| Не требует дополнительной памяти |  |
| Быстрота выполнения поиска |  |
| Просмотр элементов происходит только в одном направлении |  |

### Время работы
| Временная сложность | Время работы | Комментарий |
|----------------|---------|----------------|
| Лучшее | O(1) | В лучшем случае, когда искомый элемент находится при первом сравнении |
| Среднее | O(sqrt(n)) | в среднем этот алгоритм требует sqrt(n) итераций цикла |
| Худшее | O(sqrt(n)) | Худшему случаю соответствуют две ситуации: искомый элемент находится в последней итерации цикла, или он вовсе **отсутствует** в массиве |
